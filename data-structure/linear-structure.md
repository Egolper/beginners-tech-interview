# 선형 자료구조

> 앞뒤 자료들 간이 1:1의 선형관계를 맺는 자료구조이다.

[돌아가기](./README.md)

---

## 배열, 연결리스트

<details>
<summary>&nbsp; 배열과 연결리스트의 차이에 대해서 설명해주세요.</summary>

---

`인접메모리` `포인터`, `Random Access` `Sequential Access`

- 배열은 요소들을 연속된 물리주소 위치에 연이어 저장하고 연결리스트는 무작위 메모리 위치에 있고 포인터를 통해서 논리적으로 연결한다. 
- 따라서 특정 요소를 O(1)로 접근할 수 있다.

- 특정 요소를 삽입, 제거하려면 요소들의 메모리 위치를 재조정해야하기에 O(N)이 필요하다. 
- 요소를 삽입, 삭제할 때 노드의 포인터만 조정해주면 되기에 O(1)이 소요된다. 

- 요소들이 무작위 메모리 위치에 있고 포인터를 통해서 논리적으로 연결된다.
- 특정 요소를 탐색하기 위해 시작지점에서 부터 순차적으로 찾아가야하기에 O(N)이 소요된다.

---

</details>

<details>
<summary>&nbsp; 연결리스트의 종류에 대해서 설명해주세요.</summary>

---

- `단순 연결 리스트`  한방햔으로 
- `원형 연결 리스트` 
- `이중 연결리스트`

---

</details>

<details>
<summary>&nbsp; 연결리스트에서 중간 요소을 어떻게 효율적으로 접근할 수 있는가?</summary>

---

- 2개의 포인터를 가지고 탐색을 하는데 하나는 2개 노드씩 이동하고 하나는 1개 노드씩 이동을 한다. 2개씩 이동하는 노드가 끝에 다달았을 때 1개씩 이동하는 노드의 위치가 중간 요소이다.

---

</details>

<br>


---


## 스텍, 큐, 데크



<details>
<summary>&nbsp; 스택에 대해서 설명해주세요.</summary>

---

`후입선출` 

- 쌓아 올리는 자료구조로 가장 나중에 들어온 데이터를 빼낼할 수 있다. (top 한방향으로만 접근)
- DFS, 재귀에서 사용된다.

---

</details>

<details>
<summary>&nbsp; 큐에 대해서 설명해주세요.</summary>

---

`선입선출` `front & rear` 

- 줄을 세우는 자료구조로 먼저 들어온 데이터를 빼낼 수 있다.
- front, rear 두방향으로 접근할 수 있고 front로 데이터를 추출하고 rear로 데이터를 삽입한다.
- BFS, 캐시를 구현할 때 사용된다.

---

</details>

<details>
<summary>&nbsp; 선형큐와 원형큐에 대해서 설명해주세요.</summary>

---

`꽉 차는 기준` `공간 재활용`

![queue](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FP2AjD%2FbtqDaU3tb21%2FPRkoy9hnjkTFIkS96wrY51%2Fimg.png)

- 선형큐
  - `rear = n - 1`이면 큐가 꽉찬 것.
  - `front` 앞에 있는 공간이 낭비된다.
  - `front = rear = n - 1`일 때 큐가 비어 있으면서 꽉차 있는 놀라운 현상이 발생할 수 있다.

- 원형큐
  - 논리적으로 배열을 원형으로 재해석한 자료구조이다.
  - `rear = front - 1`이면 큐가 꽉 찬 것.
  - `rear`가 `front` 앞에 있는 공간을 활용할 수 있게 된다.
- 둘다 resize 문제를 보유하고 있다.

---

</details>

<details>
<summary>&nbsp; 데크에 대해서 설명해주세요. </summary>

---

`양방향으로 삽입과 삭제`

- 스택과 큐의 기능을 모두 가진다.
- 덱의 파생 자료구조
  - 스크롤 
    - 입력은 한쪽 끝으로만 가능하도록 제한 (입력 제한)
  - 셸프 
    - 출력은 한쪽 끝으로만 가능하도록 제한 (출력 제한)

---

</details>

<br>

---

## 해시테이블, Map, Set


<details>
<summary>&nbsp; 해시테이블에 대해서 설명해주세요.</summary>

---

`key value` `해시 함수` `해시충돌`

- 해시 함수를 통해 키와 데이터값(value)를 매핑하여 함께 저장하는 자료구조이다.
  - 해시 함수
    - 데이터를 효율적으로 관리하기 위해 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수이다.
    - 매핑된 고정된 길이의 데이터를 해시값이라고 부른다.
    - 예시. 나눗셈법, 곱셈법, universal hasing
- 데이터가 실제 저장되는 곳을 버킷 또는 슬롯이라고 한다.

---

</details>

<details>
<summary>&nbsp; 해시테이블에서 데이터 액세스할 때의 시간 복잡도에 대해서 설명해주세요.</summary>

---

`해시충돌`

- key를 바탕으로 해시연산을 하면 바로 value에 접근하기에 𝑂(1)이 소요된다.
- 최악으로 해시충돌되어 모든 버킷을 순회하기에 최악으로 𝑂(1 + 버킷수) = 𝑂(N) 소요된다.

---

</details>

<details>
<summary>&nbsp; open addressing에 대해서 설명해주세요.</summary>
<p>

- 충돌이 발생하면 다른 버킷에 데이터를 저장시킨다.
- 다른 버킷을 찾는 방법은 여러가지가 있다.

| 방식                       |                                                                                                                   |
| -------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| 선형탐색 Linear probing    | 고정적으로 폭을 증가 시킨다. h(key) +1, +2 ..                                                                     |
| 제곱탐색 Quadratic probing | 폭을 제곱수로 증가 시킨다. h(key) +2, +4 ..                                                                       |
| Random Probing             | 랜덤 함수를 통해 증가 시킨다. h(key) +난수1, +난수2 ...                                                           |
| 이중해싱 Double hashing    | 다음 해시값의 규칙성을 없애는 방법으로 이동폭을 다른 해시함수를 통해 구한다. 위 방식들이 가지는 군집화 문제 없다. |

- 어느정도 데이터가 차면 테이블 크기를 적절하게 늘려주고 처음부터 다시 해싱하는 것이 좋다.

</p>
</details>

<details>
<summary>&nbsp; chaining 방식에 대해서 설명해주세요.</summary>
<p>

- 한 버킷에 들어갈 데이터 수를 제한하지 않고 충돌되면 체인에 데이터를 추가한다.
  - 체인을 연결리스트, 레드블랙트리로 구현
- 해시가 충돌 될 때 해당 버킷 체인에 `보조 해시 함수`를 통해 해시값을 변형하여 해시 충돌 가능성을 줄인다.
- 일반적으로 open이 chaining보다 느리다.
  - 버킷 밀도가 높아지면서 open이 충돌빈도가 높이지기 때문이다.

</p>
</details>

<details>
<summary>&nbsp; map과 set의 차이점은?</summary>

---

`key == value` `key != value`

- map같은 경우 key와 value를 매핑시키는 자료구조로 key를 통해서 value를 접근할 수 있다.
- set같은 경우 key가 곧 value로 저장되는 자료구조로 집합에 value가 있는지 여부를 파악하기 쉽다.

---

</details>

<br>
